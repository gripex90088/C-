### 构造与析构

### #### C++ Primer Plus  10.3.3



+ 声明和定义构造函数 & 析构函数

```C++
/*
 构造函数的使用方式不同于其他发放，一般来说使用对象来调用方法,
 	stock1.show();// stock1 object invokes show() method
 但无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的，	因为构造函数被用来创建对象，而不能通过对象来调用
*/
class Stock
{
private:
	int m_a; // 在成员名中使用m_前缀
	int b_; // 在成员中使用后缀_
    int c;  // error 析构函数的参数表示的不是类成员，而是赋给类成员的值，因此，参数名不能与类成员相同
public:
    Stock(); // 默认构造函数 
	Stock(int a, int b, int c);
    Stock ~Stock(); // 析构函数
};

// 有参构造函数
Stock::Stock(int a, int b, int c)
{
	m_a = a; 
	b_ = b;
    c = c; // error 析构函数的参数表示的不是类成员，而是赋给类成员的值，因此，参数名不能与类成员相同
}
/*	***
	***  提示：在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数
****/
// 无参构造函数， 
Stock::Sotck()
{
    m_a = 1;
    b_ = 2;
    c = 3;
}

Stock::~Stock() // class destructor
{
    cout << "Bye, " << a << "!\n";
}

int main()
{
    // C++提供了两种使用构造函数初始化对象的方式
    Stock food = Stock(1, 2, 3); // 1, 显示的调用构造函数  初始化， 它创建有指定值的对象，可能会创建临时对象（也可能不会）；
   	
    // food = Stock(1, 2, 3); // 赋值   像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象
    /*** 
    *  提示： 如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。通常这	  *  	   种效率更高
    ****/
    Stock garment = (1, 2, 3);
    
    // 每次创建类对象(甚至使用new动态分配内存)时，C++都使用类构造函数，下面是将构造函数与new一起使用的方法
    Stock *pstock = new Stock(1, 2, 3); // 这条语句创建一个Stock对象，将其初始化为参数提供的值，并将该对象的地址赋给pstock指针，这种情况下，对象没有名称，但可以使用指针来管理对象，
    
    
    // C++列表初始化  列表初始化语法用于类
    Stock one = {1, 2, 3};
    Stock temp {};
}
```



```c++
构造函数是一种特殊的类成员函数，在创建类对象时被调用，构造函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函数，条件是每个函数的特征标（参数列表）不同。另外构造函数没有声明类型。通常，构造函数用于初始化类对象的成员，初始化应与构造函数的参数列表匹配。
```



