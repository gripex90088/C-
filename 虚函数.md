### ,虚函数

<font face="楷体" color="red">C++ Primer Plus 13.4.2</font>

+ 虚成员函数和动态联编

  + 为何有两种类型的联编

    ~~~
    动态联编能够重新定义类方法,而静态联编在这方面很差
    ~~~

  + 为何不摒弃静态联编

    1. 效率

       ~~~
       为使程序能够在运行阶段进行决策,必须采取一些方法来跟踪基类指针,或应用指向的对象类型,这增加了额外的处理开销,例如,如果类不会用作基类,则不需要动态联编.同样如果派生类不重新定义基类的任何方法,也不需要动态联编,这种情况下,使用静态联编更合理,效率更高.由于静态联编的效率更高,因此被设置为C++默认选择.
       
       Strousstrup说: C++的指导原则是,不要为不需要的特性付出代价(内存或处理时间).仅当程序设计需要虚函数时,才使用它们
       ~~~

       2. 概念模型

          ~~~
          
          ~~~

  + 虚函数的工作原理

    ~~~
    通常,编译器处理虚函数的方法时:给每个对象添加一个隐藏成员,	隐藏成员中保存了一个指向函数地址数组的指针.这种数组称为虚函数表(virtual function table,vtbl).虚函数表中存储了为类对象进行声明的虚函数的地址.派生类对象将包含一个指向独立地址表的指针.如果派生类提供了虚函数新定义,该虚函数表将保存新函数的地址,如果派生类没有重新i当以虚函数表,该vtbl将保存函数原始版本的地址.如果派生类定义了新的虚函数,则该函数的地址也将被添加到vtbl中.
    ~~~

    

  + 使用虚函数时,在内存和执行速度方面有一定的成本

    + 每个对象都将增大,增大量为存储地址空间
    + 对于每个类,编译器都创建一个虚函数地址表(数组)
    + 对于每个函数调用,都需要执行一项额外的操作,即到表中查找地址

  + 有关虚函数注意事项

    + 在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类(包括从派生类派生出来的类)中都是虚的

    + 如果使用指向对象的引用或指针来调用虚函数,程序将使用为对象类型定义的方法,而不使用为引用或指针类型定义的方法,这称为动态联编或晚期联编.这种行为非常重要,因为这样基类指针或引用可以指向派生类对象

    + 如果定义的类将被用作基类,则应将那些要在派生类中重新定义的类方法声明为虚的.

    + 虚方法的其它只是

      1. 构造函数

         ~~~
         构造函数不能是虚函数.派生类不继承基类的构造函数,所以类构造函数声明为虚的没有意义
         ~~~

         2. 析构函数

         ~~~
         析构函数应当是虚函数,除非类不用作基类.
         ~~~

         + **提示:** 通常应给基类提供一个虚析构函数,即使它并不需要析构函数

         3. 友元

         ~~~
         友元不能是虚函数,因为友元不是类成员,而只有成员才能是虚函数.如果由于这个原因引起了设计问题,可用通过让友元函数使用虚成员函数来解决
         ~~~

         4. 没有重新定义

         ~~~
         如果派生类没有重新定义函数,将使用该函数的基类版本,如果派生类位于派生链中,则将使用最新的虚函数版本,例外的情况是基类版本是隐藏的
         ~~~

         